//
// Copyright 2022 IBM Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package repository

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"time"

	iprof "github.com/argoproj-labs/argocd-interlace/pkg/apis/interlaceprofile/v1beta1"
	"github.com/argoproj-labs/argocd-interlace/pkg/application"
	appprovClientset "github.com/argoproj-labs/argocd-interlace/pkg/client/applicationprovenance/clientset/versioned"
	"github.com/argoproj-labs/argocd-interlace/pkg/config"
	"github.com/argoproj-labs/argocd-interlace/pkg/provenance"
	"github.com/argoproj-labs/argocd-interlace/pkg/sign"
	"github.com/argoproj-labs/argocd-interlace/pkg/utils/gitutil"
	yaml "github.com/ghodss/yaml"
	"github.com/pkg/errors"
	k8smnfutil "github.com/sigstore/k8s-manifest-sigstore/pkg/util"
	log "github.com/sirupsen/logrus"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
	StorageBackendRepository = "repository"
)

const DefaultSignatureResourceName = "signature-resource"
const DefaultSignatureResourceFile = "signature-resource.yaml"

type RepositoryStorageBackend struct {
	appData application.ApplicationData
	provMgr provenance.ProvenanceManager

	appProvClientset appprovClientset.Interface
	sourceConfig     iprof.ProtectionPolicySourceConfig
	gitUser          string
	gitToken         string
	gitEmail         string
	maxResults       int
	uploadTLog       bool
}

func NewStorageBackend(appData application.ApplicationData, appProvClientset appprovClientset.Interface, srcConf iprof.ProtectionPolicySourceConfig, gitUser, gitToken, gitEmail string, maxResults int, uploadTLog bool) (*RepositoryStorageBackend, error) {
	return &RepositoryStorageBackend{
		appData:          appData,
		appProvClientset: appProvClientset,
		sourceConfig:     srcConf,
		gitUser:          gitUser,
		gitToken:         gitToken,
		gitEmail:         gitEmail,
		maxResults:       maxResults,
		uploadTLog:       uploadTLog,
	}, nil
}

func (s *RepositoryStorageBackend) GetLatestManifestContent() ([]byte, error) {
	return nil, nil
}

func (s *RepositoryStorageBackend) StoreManifestBundle(sourceVerifed bool, privkeyBytes []byte) error {

	manifestPath := filepath.Join(s.appData.AppDirPath, config.MANIFEST_FILE_NAME)
	signedManifestPath := filepath.Join(s.appData.AppDirPath, config.SIGNED_MANIFEST_FILE_NAME)

	manifestBytes, err := ioutil.ReadFile(manifestPath)
	if err != nil {
		return errors.Wrap(err, "error in reading manifest")
	}
	log.Debugf("manifest bytes: %s", string(manifestBytes))

	doSigning := true
	// if signing key is empty, do not sign the manifest and return here
	if string(privkeyBytes) == "" {
		log.Warnf("signing key is empty, so skip signing the manifest")
		doSigning = false
	}

	if doSigning {
		privkeyFile, err := ioutil.TempFile("", "privkey")
		if err != nil {
			return errors.Wrap(err, "error in creating a temp file")
		}
		defer os.Remove(privkeyFile.Name())

		_, err = privkeyFile.Write(privkeyBytes)
		if err != nil {
			return errors.Wrap(err, "error in saving the signing key as a temp file")
		}

		keyPath := privkeyFile.Name()
		signedBytes, err := sign.SignManifest(keyPath, manifestPath, signedManifestPath)
		if err != nil {
			return errors.Wrap(err, "error in signing manifest")
		}
		manifestBytes = signedBytes
	}
	manifestYAMLs := k8smnfutil.SplitConcatYAMLs(manifestBytes)

	log.Info("len(manifestYAMLs): ", len(manifestYAMLs))

	sigResPath := filepath.Join(s.sourceConfig.Path, DefaultSignatureResourceFile)

	signatureResource, err := SignedManifestToSignatureResource(manifestBytes)
	if err != nil {
		return errors.Wrap(err, "failed to create a signature resource")
	}
	signatureResourceBytes, err := yaml.Marshal(signatureResource)
	if err != nil {
		return errors.Wrap(err, "failed to marshal a signature resource")
	}
	log.Infof("signatureResource: %s", string(signatureResourceBytes))

	url := s.sourceConfig.URL
	branch := s.sourceConfig.Branch
	user := s.gitUser
	email := s.gitEmail
	token := s.gitToken
	commitMsg := "signature is generated by ArgoCD Interlace"
	createOrUpdate := map[string][]byte{
		sigResPath: signatureResourceBytes,
	}
	err = gitutil.CommitAndPush(url, branch, user, email, token, commitMsg, createOrUpdate, nil)
	if err != nil {
		return errors.Wrap(err, "failed to push the generated signature to remote repository")
	}
	return nil
}

func (s *RepositoryStorageBackend) StoreManifestProvenance(buildStartedOn time.Time, buildFinishedOn time.Time, sourceVerified bool, privkeyBytes []byte) error {
	log.Info("RepositoryStorageBackend.StoreManifestProvenance() does nothing currently")
	return nil
}

func (b *RepositoryStorageBackend) UploadTLogEnabled() bool {
	return b.uploadTLog
}

func (b *RepositoryStorageBackend) GetDestinationString() string {
	return fmt.Sprintf("ApplicationProvenance `%s`", b.appData.AppName)
}

func (b *RepositoryStorageBackend) GetProvenanceManager() provenance.ProvenanceManager {
	return b.provMgr
}

func (b *RepositoryStorageBackend) Type() string {
	return StorageBackendRepository
}

func SignedManifestToSignatureResource(manifestBytes []byte) (cm *corev1.ConfigMap, err error) {
	var manifestYAMLs [][]byte
	if k8smnfutil.IsConcatYAMLs(manifestBytes) {
		manifestYAMLs = k8smnfutil.SplitConcatYAMLs(manifestBytes)
	} else {
		manifestYAMLs = [][]byte{manifestBytes}
	}
	if len(manifestYAMLs) == 0 {
		return nil, errors.New("no signed manifest found")
	}
	annotations := k8smnfutil.GetAnnotationsInYAML(manifestYAMLs[0])
	annotationsBytes, _ := json.Marshal(annotations)
	log.Debugf("signature annotations: %s", string(annotationsBytes))
	message, msgOK := annotations[config.MSG_ANNOTATION_NAME]
	signature, sigOK := annotations[config.SIG_ANNOTATION_NAME]
	certificate, crtOK := annotations[config.CRT_ANNOTATION_NAME]
	bundle, bdlOK := annotations[config.BDL_ANNOTATION_NAME]
	if !msgOK || message == "" {
		return nil, errors.New("message annotation not found")
	}
	if !sigOK || signature == "" {
		return nil, errors.New("signature annotation not found")
	}
	interlaceConfig, err := config.GetInterlaceConfig()
	if err != nil {
		return nil, errors.New("failed to get interlace config")
	}
	signatureResource := &corev1.ConfigMap{
		TypeMeta: metav1.TypeMeta{
			APIVersion: "v1",
			Kind:       "ConfigMap",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name: DefaultSignatureResourceName,
			Labels: map[string]string{
				interlaceConfig.SignatureResourceLabel: "true",
			},
		},
		Data: map[string]string{
			"message":   message,
			"signature": signature,
		},
	}
	if crtOK && certificate != "" {
		signatureResource.Data["certificate"] = certificate
	}
	if bdlOK && bundle != "" {
		signatureResource.Data["bundle"] = bundle
	}
	return signatureResource, nil
}
