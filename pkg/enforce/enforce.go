//
// Copyright 2022 IBM Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package enforce

import (
	_ "embed"
	"reflect"

	iprof "github.com/argoproj-labs/argocd-interlace/pkg/apis/interlaceprofile/v1beta1"
	"github.com/argoproj-labs/argocd-interlace/pkg/utils/gitutil"
	"github.com/ghodss/yaml"
	"github.com/pkg/errors"
)

const (
	IntegrityShieldType = "integrity-shield"
	KyvernoType         = "kyverno"
	CustomType          = "custom"
)

const defaultType = IntegrityShieldType

const defaultEnforceRuleFile = "enforce-rule.yaml"

//go:embed templates/integrity-shield-rule.yaml
var integrityShieldTemplate []byte

var templates = map[string][]byte{
	IntegrityShieldType: integrityShieldTemplate,
	KyvernoType:         nil, // TODO: support kyverno template
	CustomType:          nil, // TODO: support custom type
}

func GenerateRule(ruleType, ruleName, sigResName string, patterns []iprof.ResourceMatchPattern, pubkeyBytes []byte, sourceConfig iprof.ProtectionPolicySourceConfig, gitUser, gitToken, gitEmail string) error {
	if ruleType == "" {
		ruleType = defaultType
	}
	template, ok := templates[ruleType]
	if !ok {
		return errors.New("\"%s\" is not supported for generating enforce rule")
	}
	ruleManifests, err := GenerateEnforceRuleFromTemplate(ruleType, template, ruleName, sigResName, patterns, pubkeyBytes)
	if err != nil {
		return errors.Wrap(err, "failed to generate a rule manifest from template")
	}

	url := sourceConfig.URL
	branch := sourceConfig.Branch
	user := gitUser
	email := gitEmail
	token := gitToken
	commitMsg := "an enforce rule is generated by ArgoCD Interlace"
	createOrUpdate := map[string][]byte{
		defaultEnforceRuleFile: ruleManifests,
	}
	err = gitutil.CommitAndPush(url, branch, user, email, token, commitMsg, createOrUpdate, nil)
	if err != nil {
		return errors.Wrap(err, "failed to commit and push the generated enforce rule")
	}
	return nil
}

// TODO: avoid ad-hoc way
func GenerateEnforceRuleFromTemplate(ruleType string, template []byte, ruleName, sigResName string, patterns []iprof.ResourceMatchPattern, pubkeyBytes []byte) ([]byte, error) {
	var ruleBytes []byte
	var err error
	if ruleType == IntegrityShieldType {
		var ruleMap map[string]interface{}
		err = yaml.Unmarshal(template, &ruleMap)
		if err != nil {
			return nil, err
		}
		metadataMap := ruleMap["metadata"].(map[string]interface{})
		metadataMap["name"] = ruleName
		specMap := ruleMap["spec"].(map[string]interface{})
		parametersMap := specMap["parameters"].(map[string]interface{})
		parametersMap["constraintName"] = ruleName
		groups := []string{}
		kinds := []string{}
		namespaces := []string{}
		names := []map[string]interface{}{}
		nameList := []string{}
		for _, pattern := range patterns {
			if !contains(groups, pattern.Group) {
				groups = append(groups, pattern.Group)
			}
			if pattern.Kind != "" && !contains(kinds, pattern.Kind) {
				kinds = append(kinds, pattern.Kind)
			}
			if pattern.Namespace != "" && !contains(namespaces, pattern.Namespace) {
				namespaces = append(namespaces, pattern.Namespace)
			}
			if pattern.Name != "" && !contains(nameList, pattern.Name) {
				nameList = append(nameList, pattern.Name)
				names = append(names, map[string]interface{}{"name": pattern.Name})
			}
		}
		sigResNamespace := ""
		if len(namespaces) > 0 {
			sigResNamespace = namespaces[0]
		}
		matchMap := specMap["match"].(map[string]interface{})
		kindsSlice := matchMap["kinds"].([]interface{})
		kindsMap := kindsSlice[0].(map[string]interface{})
		kindsMap["apiGroups"] = groups
		kindsMap["kinds"] = kinds
		kindsSlice[0] = kindsMap
		matchMap["kinds"] = kindsSlice
		matchMap["namespaces"] = namespaces
		keyConfigMap := []map[string]interface{}{}
		keyConfigElemMap := map[string]interface{}{}
		keyMap := map[string]interface{}{}
		keyMap["name"] = ruleName
		keyMap["PEM"] = string(pubkeyBytes)
		keyConfigElemMap["key"] = keyMap
		keyConfigMap = append(keyConfigMap, keyConfigElemMap)
		sigResRefMap := map[string]interface{}{}
		sigResRefMap["name"] = sigResName
		sigResRefMap["namespace"] = sigResNamespace
		sigRefMap := map[string]interface{}{}
		sigRefMap["signatureResourceRef"] = sigResRefMap
		parametersMap["keyConfigs"] = keyConfigMap
		parametersMap["signatureRef"] = sigRefMap
		parametersMap["objectSelector"] = names
		specMap["match"] = matchMap
		specMap["parameters"] = parametersMap
		ruleMap["metadata"] = metadataMap
		ruleMap["spec"] = specMap
		ruleBytes, err = yaml.Marshal(ruleMap)
	}
	return ruleBytes, err
}

func contains(list, subject interface{}) bool {
	vSubject := reflect.ValueOf(subject)
	switch reflect.TypeOf(list).Kind() {
	case reflect.Slice:
		vList := reflect.ValueOf(list)
		for i := 0; i < vList.Len(); i++ {
			if reflect.DeepEqual(vList.Index(i).Interface(), vSubject.Interface()) {
				return true
			}
		}
	}
	return false
}
